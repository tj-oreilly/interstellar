import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from itertools import combinations
from math import sqrt

# Constants
SPEED_OF_LIGHT = 9.715e-9  # pc/s
GRAVITATIONAL_CONST = 6.67430e-11  # m^3 kg^-1 s^-2
SOLAR_MASS = 1.989e30  # kg
SOLAR_RADIUS = 695700  # km
PROBE_MASS = 478  # kg
PC_TO_M = 3.0857e16
SECONDS_IN_YEAR = 31_557_600

# Parameters
N_STOPS = 6
GAIA_data_path = "GAIA_data/data_GAIA_radius_=_20pc_parallax_error<5percent.csv"

sun_coord = pd.DataFrame({'x [pc]': [0.0], 'y [pc]': [0.0]})
sun_params = pd.DataFrame({
    'ra': [0.0], 'dec': [0.0], 'parallax': [1.0],
    'teff_gspphot': [5778.0], 'radius_gspphot': [1.0], 'mass_flame': [1.0],
    'mass_flame_upper': [1.1], 'mass_flame_lower': [0.9], 'radius_flame_upper': [1.1]
})

def take_stars():
    global stars_coordinates, stars_parameters
    data = pd.read_csv(GAIA_data_path)
    ra_rad = np.deg2rad(data['ra'])
    dec_rad = np.deg2rad(data['dec'])
    distance_pc = 1000 / data['parallax']
    data['x [pc]'] = distance_pc * np.cos(dec_rad) * np.cos(ra_rad)
    data['y [pc]'] = distance_pc * np.cos(dec_rad) * np.sin(ra_rad)
    stars_coordinates = pd.concat([sun_coord, data[['x [pc]', 'y [pc]']]], ignore_index=True)
    stars_parameters = pd.concat([sun_params, data.drop(columns=['x [pc]', 'y [pc]'])], ignore_index=True)

def generate_stops(seed=None):
    return [0] + stars_coordinates.iloc[1:].sample(n=N_STOPS, random_state=seed).index.tolist()

def compute_distance(x1, y1, x2, y2):
    return sqrt((x2 - x1)**2 + (y2 - y1)**2)

def deflection_angle(path):
    results = []
    for i in range(1, len(path) - 1):
        a = stars_coordinates.loc[path[i - 1]].values
        b = stars_coordinates.loc[path[i]].values
        c = stars_coordinates.loc[path[i + 1]].values
        vec_in = a - b
        vec_out = c - b
        dot = np.dot(vec_in, vec_out) / (np.linalg.norm(vec_in) * np.linalg.norm(vec_out))
        theta = np.arccos(np.clip(dot, -1.0, 1.0))
        deflection = np.pi - theta
        results.append((path[i], np.degrees(deflection)))
        
    return results

def vmax_for_stars(deflections):
    results = []
    for idx, angle_deg in deflections:
        theta = np.radians(angle_deg)
        M = stars_parameters.loc[idx, 'mass_flame'] * SOLAR_MASS
        R = stars_parameters.loc[idx, 'radius_flame_upper'] * SOLAR_RADIUS * 1e3 + 5000  # km to m
        if theta == 0 or np.sin(theta / 2) == 0:
            vmax = 0.0
        else:
            vmax = np.sqrt(GRAVITATIONAL_CONST * M / R * (1 / np.sin(theta / 2) - 1))
        results.append(vmax / PC_TO_M)  # convert to pc/s
    return results

def r0_from_velocity(deflections, v):
    results = []
    for idx, angle_deg in deflections:
        theta = np.radians(angle_deg)
        M = stars_parameters.loc[idx, 'mass_flame'] * SOLAR_MASS
        if theta == 0 or np.sin(theta / 2) == 0:
            r0 = float('inf')
        else:
            r0 = GRAVITATIONAL_CONST * M / (v * PC_TO_M)**2 * (1 / np.sin(theta / 2) - 1)
        results.append((idx, r0 * 1e-3))  # in km
    return results

def r0_uncertainty(deflections, v):
    results = []
    for idx, angle_deg in deflections:
        theta = np.radians(angle_deg)
        M = stars_parameters.loc[idx, 'mass_flame'] * SOLAR_MASS
        dM = ((stars_parameters.loc[idx, 'mass_flame_upper'] - stars_parameters.loc[idx, 'mass_flame_lower']) / 2) * SOLAR_MASS
        if theta == 0 or np.sin(theta / 2) == 0:
            sigma_r0 = float('inf')
        else:
            dr0_dM = GRAVITATIONAL_CONST / (v * PC_TO_M)**2 * (1 / np.sin(theta / 2) - 1)
            sigma_r0 = dr0_dM * dM / 1e3
        results.append((idx, sigma_r0))
    return results


def held_karp_path(stops):
    n = len(stops)
    matrix = [[float('inf')] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i != j:
                xi, yi = stars_coordinates.loc[stops[i]].values
                xj, yj = stars_coordinates.loc[stops[j]].values
                matrix[i][j] = compute_distance(xi, yi, xj, yj)

    C = {}
    for k in range(1, n):
        C[(frozenset([k]), k)] = (matrix[0][k], [0, k])

    for s in range(2, n):
        for subset in combinations(range(1, n), s):
            S = frozenset(subset)
            for k in subset:
                prev_set = S - {k}
                min_cost, best_path = float('inf'), []
                for m in prev_set:
                    cost, path = C[(prev_set, m)]
                    new_cost = cost + matrix[m][k]
                    if new_cost < min_cost:
                        min_cost = new_cost
                        best_path = path + [k]
                C[(S, k)] = (min_cost, best_path)

    full = frozenset(range(1, n))
    min_cost, best = float('inf'), []
    for k in range(1, n):
        cost, path = C[(full, k)]
        if cost < min_cost:
            min_cost = cost
            best = path

    return [stops[i] for i in best]

def simulate():
    take_stars()
    valid_count = 0
    for seed in range(10000):
        stops = generate_stops(seed=seed)
        path = held_karp_path(stops)
        deflections = deflection_angle(path)
        vmax_list = vmax_for_stars(deflections)

        if not vmax_list:
            continue

        v_min = min(vmax_list)
        r0s = r0_from_velocity(deflections, v_min)
        uncertainties = r0_uncertainty(deflections, v_min)

        is_valid, bad_idx, bad_r0, bad_sigma, bad_R = check_validity(r0s, uncertainties, deflections)
        
        if is_valid:
            valid_count += 1
            log_results(deflections, r0s, uncertainties, v_min, seed, valid=True)
        else:
            log_results(deflections, r0s, uncertainties, v_min, seed, valid=False, bad_star=(bad_idx, bad_r0, bad_sigma, bad_R))
    
    print(f"Number of valid simulations: {valid_count}/10000")


def check_validity(r0s, uncertainties, deflections):
    r0_dict = {idx: r0 for idx, r0 in r0s}
    sigma_dict = {idx: sigma for idx, sigma in uncertainties}
    angle_dict = {idx: np.radians(angle_deg) for idx, angle_deg in deflections}
    mass_dict = {idx: stars_parameters.loc[idx, 'mass_flame'] * SOLAR_MASS for idx, _ in deflections}
    
    
    for (idx, r0) in r0s:
        sigma = sigma_dict[idx]
        R = stars_parameters.loc[idx, 'radius_flame_lower'] * SOLAR_RADIUS  # in km
        if r0 - sigma < R:
            return False, idx, r0, sigma, R  # standard validity check failed
    
    # Additional adjacent deflection check
    for i in range(1, len(deflections) - 1):
        idx_A = deflections[i - 1][0]
        idx_B = deflections[i][0]

        r_a = r0_dict[idx_A]
        r_b = r0_dict[idx_B]
        M_A = mass_dict[idx_A]
        M_B = mass_dict[idx_B]
        θ_A = angle_dict[idx_A]
        θ_B = angle_dict[idx_B]

        # Avoid divide-by-zero
        sin_half_θ_A = np.sin(θ_A / 2)
        sin_half_θ_B = np.sin(θ_B / 2)

        if sin_half_θ_A == 0 or sin_half_θ_B == 0:
            continue

        lhs = r_a / r_b
        rhs = (M_B / M_A) * ((1 / sin_half_θ_B - 1) / (1 / sin_half_θ_A - 1))

        if not np.isclose(lhs, rhs, rtol=0.5):  # use ~20% tolerance
            # Mark second star as the failure point
            return False, idx_B, r_b, sigma_dict[idx_B], stars_parameters.loc[idx_B, 'radius_flame_upper'] * SOLAR_RADIUS

    return True, None, None, None, None


def log_results(deflections, r0s, r0_uncertainties, v, seed, valid=True, bad_star=None):
    os.makedirs("Logs", exist_ok=True)
    with open("Logs/downgraded_log.txt", "a") as f:
        f.write(f"=== Simulation (seed = {seed}) ===\n")
        f.write(f"Minimum velocity used (from vmax): {v:.3e} pc/s\n")

        f.write(f"\n--- Star-by-Star Slingshot Data ---\n")
        for (idx, angle), (_, r0), (_, sigma_r0) in zip(deflections, r0s, r0_uncertainties):
            R = stars_parameters.loc[idx, 'radius_flame_upper'] * SOLAR_RADIUS  # in km
            f.write(f"Star index: {idx}\n")
            f.write(f"  Deflection angle: {angle:.3f} deg\n")
            f.write(f"  Stellar radius R: {R:.3e} km\n")
            f.write(f"  Periapsis r0: {r0:.3e} ± {sigma_r0:.2e} km\n")

        if not valid and bad_star:
            bad_idx, bad_r0, bad_sigma, bad_R = bad_star
            f.write("\n❌ INVALID PATH DETECTED\n")
            f.write(f"Violating Star index: {bad_idx}\n")
            f.write(f"  r0 - σ_r0 = {bad_r0 - bad_sigma:.3e} km < R = {bad_R:.3e} km\n")

        f.write("\n")




if __name__ == "__main__":
    simulate()
